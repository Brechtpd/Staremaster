import { spawn } from 'node:child_process';
import path from 'node:path';
import { setTimeout as delay } from 'node:timers/promises';
import { parseCodexExecJson } from '../services/CodexSummarizer';
import type { TaskRecord, WorkerRole } from '@shared/orchestrator';

export interface ExecutionContext {
  worktreePath: string;
  runId: string;
  task: TaskRecord;
  role: WorkerRole;
  onLog(chunk: string, source: 'stdout' | 'stderr'): void;
  signal: AbortSignal;
  model?: string;
}

export interface ExecutionResult {
  summary: string;
  artifacts: ExecutionArtifact[];
}

export interface CodexExecutor {
  execute(context: ExecutionContext): Promise<ExecutionResult>;
}

export interface ExecutionArtifact {
  /**
   * Relative path (inside the orchestrator run root) where the artifact should be stored.
   * Example: `artifacts/ANALYSIS-123.md`.
   */
  path: string;
  /** File contents, typically markdown. */
  contents: string;
}

interface CodexCliExecutorOptions {
  /** Override Codex binary path; defaults to `process.env.CODEX_BIN ?? 'codex'`. */
  bin?: string;
  /** Directory (relative to run root) where artifacts will be written. */
  artifactDir?: string;
  /** Environment variable prefix for per-role profiles (e.g. `CODEX_PROFILE_ANALYST_A`). */
  profileEnvPrefix?: string;
}

const DEFAULT_ARTIFACT_DIR = 'artifacts';
const DEFAULT_SUMMARY_FALLBACK = 'Codex run completed.';

/**
 * Temporary stub executor that simulates Codex output. Replace with a real
 * CodexSessionManager-backed implementation once available.
 */
export class StubCodexExecutor implements CodexExecutor {
  async execute(context: ExecutionContext): Promise<ExecutionResult> {
    context.onLog(`Simulating ${context.role} execution for ${context.task.title}\n`, 'stdout');
    await delay(250, undefined, { signal: context.signal }).catch(() => undefined);
    const summary = `Automated summary for ${context.task.id} generated by stub executor.`;
    const artifactPath = `${DEFAULT_ARTIFACT_DIR}/${context.task.id}.md`;
    return {
      summary,
      artifacts: [
        {
          path: artifactPath,
          contents: `# Stub Output\n\n${summary}\n`
        }
      ]
    };
  }
}

export class CodexCliExecutor implements CodexExecutor {
  private readonly options: Required<CodexCliExecutorOptions>;

  constructor(options: CodexCliExecutorOptions = {}) {
    this.options = {
      bin: options.bin ?? process.env.CODEX_BIN ?? 'codex',
      artifactDir: options.artifactDir ?? DEFAULT_ARTIFACT_DIR,
      profileEnvPrefix: options.profileEnvPrefix ?? 'CODEX_PROFILE_'
    };
  }

  async execute(context: ExecutionContext): Promise<ExecutionResult> {
    const args = ['exec', '--json'];
    const profile = this.resolveProfile(context.role);
    const model = context.model;
    if (profile) {
      args.push('--profile', profile);
    }
    if (model) {
      args.push('--model', model);
    }
    args.push('-');

    return await new Promise<ExecutionResult>((resolve, reject) => {
      const child = spawn(this.options.bin, args, {
        cwd: context.task.cwd ? path.join(context.worktreePath, context.task.cwd) : context.worktreePath,
        env: this.buildEnv(context)
      });

      let stdout = '';
      let stderr = '';
      let settled = false;

      const cleanup = () => {
        settled = true;
        context.signal.removeEventListener('abort', abortListener);
      };

      const abortListener = () => {
        if (!child.killed) {
          child.kill('SIGTERM');
        }
      };

      context.signal.addEventListener('abort', abortListener, { once: true });

      child.stdout?.setEncoding('utf8');
      child.stderr?.setEncoding('utf8');

      child.stdout?.on('data', (chunk: string) => {
        stdout += chunk;
        context.onLog(chunk, 'stdout');
      });

      child.stderr?.on('data', (chunk: string) => {
        stderr += chunk;
        context.onLog(chunk, 'stderr');
      });

      child.on('error', (error) => {
        if (settled) {
          return;
        }
        cleanup();
        reject(error);
      });

      child.on('close', (code) => {
        if (settled) {
          return;
        }
        cleanup();
        if (context.signal.aborted) {
          reject(new Error('Codex execution aborted'));
          return;
        }

        if (code !== 0) {
          const error = stderr.trim() || stdout.trim() || `codex exited with code ${code}`;
          reject(new Error(error));
          return;
        }

        const parsed = parseCodexExecJson(stdout);
        const message = parsed.message?.trim() || stdout.trim() || DEFAULT_SUMMARY_FALLBACK;
        const artifactPath = this.buildArtifactPath(context);
        resolve({
          summary: message,
          artifacts: [
            {
              path: artifactPath,
              contents: `${message}\n`
            }
          ]
        });
      });

      if (child.stdin) {
        child.stdin.setDefaultEncoding('utf8');
        child.stdin.write(context.task.prompt);
        child.stdin.end();
      }
    });
  }

  private buildEnv(context: ExecutionContext): NodeJS.ProcessEnv {
    const env: NodeJS.ProcessEnv = {
      ...process.env,
      CODEX_RUN_ID: context.runId,
      CODEX_ORCHESTRATOR_ROLE: context.role,
      CODEX_ORCHESTRATOR_TASK_ID: context.task.id
    };
    if (!env.CODEX_THINKING_MODE) {
      env.CODEX_THINKING_MODE = 'low';
    }
    if (!env.CODEX_COMPLEXITY) {
      env.CODEX_COMPLEXITY = 'low';
    }
    if (!env.CODEX_REASONING_EFFORT) {
      env.CODEX_REASONING_EFFORT = 'low';
    }
    return env;
  }

  private resolveProfile(role: WorkerRole): string | null {
    const key = `${this.options.profileEnvPrefix}${role}`.toUpperCase();
    const explicit = process.env[key];
    if (explicit && explicit.trim()) {
      return explicit.trim();
    }
    return null;
  }

  private buildArtifactPath(context: ExecutionContext): string {
    const baseName = `${context.task.id}.md`;
    return path.join(this.options.artifactDir, baseName).replace(/\\/g, '/');
  }
}
