import { spawn } from 'node:child_process';
import path from 'node:path';
import { setTimeout as delay } from 'node:timers/promises';
import { parseCodexExecJson } from '../services/CodexSummarizer';
import type { TaskRecord, WorkerOutcomeDocument, WorkerOutcomeStatus, WorkerRole } from '@shared/orchestrator';

export interface ExecutionContext {
  worktreePath: string;
  runId: string;
  task: TaskRecord;
  role: WorkerRole;
  onLog(chunk: string, source: 'stdout' | 'stderr'): void;
  signal: AbortSignal;
  model?: string;
}

export interface ExecutionResult {
  summary: string;
  artifacts: ExecutionArtifact[];
  outcome: WorkerOutcomeDocument;
}

export interface CodexExecutor {
  execute(context: ExecutionContext): Promise<ExecutionResult>;
}

export interface ExecutionArtifact {
  /**
   * Relative path (inside the orchestrator run root) where the artifact should be stored.
   * Example: `artifacts/ANALYSIS-123.md`.
   */
  path: string;
  /** File contents, typically markdown. */
  contents: string;
}

interface CodexCliExecutorOptions {
  /** Override Codex binary path; defaults to `process.env.CODEX_BIN ?? 'codex'`. */
  bin?: string;
  /** Directory (relative to run root) where artifacts will be written. */
  artifactDir?: string;
  /** Environment variable prefix for per-role profiles (e.g. `CODEX_PROFILE_ANALYST_A`). */
  profileEnvPrefix?: string;
}

const DEFAULT_ARTIFACT_DIR = 'artifacts';
const DEFAULT_SUMMARY_FALLBACK = 'Codex run completed.';

const STATUS_ALIASES: Record<string, WorkerOutcomeStatus> = {
  OK: 'ok',
  APPROVED: 'ok',
  SUCCESS: 'ok',
  PASS: 'ok',
  PASSED: 'ok',
  COMPLETE: 'ok',
  COMPLETED: 'ok',
  CHANGES_REQUESTED: 'changes_requested',
  CHANGESREQUESTED: 'changes_requested',
  NEEDS_CHANGES: 'changes_requested',
  NEEDSCHANGES: 'changes_requested',
  REVISION_REQUIRED: 'changes_requested',
  REVISIONREQUIRED: 'changes_requested',
  BLOCKED: 'blocked',
  FAILED: 'changes_requested',
  FAIL: 'changes_requested'
};

const normalizeOutcomeStatus = (value: unknown): WorkerOutcomeStatus | null => {
  if (typeof value !== 'string') {
    return null;
  }
  const normalized = value.trim().toUpperCase().replace(/[^A-Z0-9]+/g, '_');
  if (!normalized) {
    return null;
  }
  return STATUS_ALIASES[normalized] ?? null;
};

const stripCodeFence = (payload: string): string => {
  const trimmed = payload.trim();
  const fenceMatch = trimmed.match(/^```(?:json)?\s*([\s\S]*?)```$/i);
  if (fenceMatch) {
    return fenceMatch[1].trim();
  }
  return trimmed;
};

const extractJsonCandidate = (payload: string): string | null => {
  const stripped = stripCodeFence(payload);
  if (!stripped) {
    return null;
  }
  if (stripped.startsWith('{') && stripped.endsWith('}')) {
    return stripped;
  }
  const firstBrace = stripped.indexOf('{');
  const lastBrace = stripped.lastIndexOf('}');
  if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
    return stripped.slice(firstBrace, lastBrace + 1);
  }
  return null;
};

const toWorkerOutcome = (message: string): WorkerOutcomeDocument => {
  const fallbackSummary = message.trim() || DEFAULT_SUMMARY_FALLBACK;
  const candidate = extractJsonCandidate(message);
  if (candidate) {
    try {
      const parsed = JSON.parse(candidate) as Record<string, unknown>;
      const status = normalizeOutcomeStatus(parsed.status) ?? 'changes_requested';
      const summaryRaw = typeof parsed.summary === 'string' ? parsed.summary.trim() : '';
      const summary = summaryRaw || fallbackSummary;
      const detailsRaw = typeof parsed.details === 'string' ? parsed.details.trim() : undefined;
      return {
        status,
        summary,
        details: detailsRaw
      };
    } catch (error) {
      console.warn('[orchestrator] failed to parse structured outcome', {
        message: (error as Error).message
      });
    }
  }
  const trimmed = message.trim();
  return {
    status: 'changes_requested',
    summary: fallbackSummary,
    details: trimmed && trimmed !== fallbackSummary ? trimmed : undefined
  };
};

/**
 * Temporary stub executor that simulates Codex output. Replace with a real
 * CodexSessionManager-backed implementation once available.
 */
export class StubCodexExecutor implements CodexExecutor {
  async execute(context: ExecutionContext): Promise<ExecutionResult> {
    context.onLog(`Simulating ${context.role} execution for ${context.task.title}\n`, 'stdout');
    await delay(250, undefined, { signal: context.signal }).catch(() => undefined);
    const summary = `Automated summary for ${context.task.id} generated by stub executor.`;
    const artifactPath = `${DEFAULT_ARTIFACT_DIR}/${context.task.id}.md`;
    const outcome: WorkerOutcomeDocument = {
      status: 'ok',
      summary,
      details: 'Stub executor reports successful completion.'
    };
    return {
      summary,
      artifacts: [
        {
          path: artifactPath,
          contents: `# Stub Output\n\n${summary}\n`
        }
      ],
      outcome
    };
  }
}

export class CodexCliExecutor implements CodexExecutor {
  private readonly options: Required<CodexCliExecutorOptions>;

  constructor(options: CodexCliExecutorOptions = {}) {
    this.options = {
      bin: options.bin ?? process.env.CODEX_BIN ?? 'codex',
      artifactDir: options.artifactDir ?? DEFAULT_ARTIFACT_DIR,
      profileEnvPrefix: options.profileEnvPrefix ?? 'CODEX_PROFILE_'
    };
  }

  async execute(context: ExecutionContext): Promise<ExecutionResult> {
    const args = ['exec', '--json', '--full-auto'];
    const profile = this.resolveProfile(context.role);
    const model = context.model;
    if (profile) {
      args.push('--profile', profile);
    }
    if (model) {
      args.push('--model', model);
    }
    args.push('-');

    return await new Promise<ExecutionResult>((resolve, reject) => {
      const child = spawn(this.options.bin, args, {
        cwd: context.task.cwd ? path.join(context.worktreePath, context.task.cwd) : context.worktreePath,
        env: this.buildEnv(context)
      });

      let stdout = '';
      let stderr = '';
      let settled = false;

      const cleanup = () => {
        settled = true;
        context.signal.removeEventListener('abort', abortListener);
      };

      const abortListener = () => {
        if (!child.killed) {
          child.kill('SIGTERM');
        }
      };

      context.signal.addEventListener('abort', abortListener, { once: true });

      child.stdout?.setEncoding('utf8');
      child.stderr?.setEncoding('utf8');

      child.stdout?.on('data', (chunk: string) => {
        stdout += chunk;
        context.onLog(chunk, 'stdout');
      });

      child.stderr?.on('data', (chunk: string) => {
        stderr += chunk;
        context.onLog(chunk, 'stderr');
      });

      child.on('error', (error) => {
        if (settled) {
          return;
        }
        cleanup();
        reject(error);
      });

      child.on('close', (code) => {
        if (settled) {
          return;
        }
        cleanup();
        if (context.signal.aborted) {
          reject(new Error('Codex execution aborted'));
          return;
        }

        if (code !== 0) {
          const error = stderr.trim() || stdout.trim() || `codex exited with code ${code}`;
          reject(new Error(error));
          return;
        }

        const parsed = parseCodexExecJson(stdout);
        const message = parsed.message?.trim() || stdout.trim() || DEFAULT_SUMMARY_FALLBACK;
        const outcome = toWorkerOutcome(message);
        const artifactPath = this.buildArtifactPath(context);
        resolve({
          summary: outcome.summary,
          artifacts: [
            {
              path: artifactPath,
              contents: `${message}\n`
            }
          ],
          outcome
        });
      });

      if (child.stdin) {
        child.stdin.setDefaultEncoding('utf8');
        child.stdin.write(context.task.prompt);
        child.stdin.end();
      }
    });
  }

  private buildEnv(context: ExecutionContext): NodeJS.ProcessEnv {
    const env: NodeJS.ProcessEnv = {
      ...process.env,
      CODEX_RUN_ID: context.runId,
      CODEX_ORCHESTRATOR_ROLE: context.role,
      CODEX_ORCHESTRATOR_TASK_ID: context.task.id
    };
    if (!env.CODEX_THINKING_MODE) {
      env.CODEX_THINKING_MODE = 'low';
    }
    if (!env.CODEX_COMPLEXITY) {
      env.CODEX_COMPLEXITY = 'low';
    }
    if (!env.CODEX_REASONING_EFFORT) {
      env.CODEX_REASONING_EFFORT = 'low';
    }
    return env;
  }

  private resolveProfile(role: WorkerRole): string | null {
    const key = `${this.options.profileEnvPrefix}${role}`.toUpperCase();
    const explicit = process.env[key];
    if (explicit && explicit.trim()) {
      return explicit.trim();
    }
    return null;
  }

  private buildArtifactPath(context: ExecutionContext): string {
    const baseName = `${context.task.id}.md`;
    return path.join(this.options.artifactDir, baseName).replace(/\\/g, '/');
  }
}
